---
title: "Projeto 2 Astrometria"
author: "André Almeida Trovello"
format: pdf
---
# Estudo de regiões de formação estelar (Taurus) com métodos de Machine Learning

# 1. Query
### Importando Bibliotecas

```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from astroquery.gaia import Gaia
from sklearn.cluster import KMeans, DBSCAN, HDBSCAN
from sklearn.metrics import silhouette_score, silhouette_samples
from astropy.table import Table
```

### Criando Dataframe
```{python}
data = pd.read_csv('galli_2019_table1.csv')
main_table = pd.DataFrame(data)
```

### Tabela do Vizier

```{python}
# Garanta que a variável 'main_table' exista.
try:
    # Se já tiver 'main_table' na memória (ex: num notebook), pula
    main_table
    print("Variável 'main_table' já existe na memória.")
except NameError:
    try:
        # Tente carregar do CSV
        main_table = Table.read('galli_2019_table1.csv') 
        print("Arquivo 'galli_2019_table1.csv' carregado com sucesso.")
    except FileNotFoundError:
        print("Erro: A variável 'main_table' não foi encontrada na memória.")
        print("E o arquivo 'galli_2019_table1.csv' não \
            foi encontrado no disco.")
        print("Por favor, rode o script do VizieR \
            primeiro ou verifique o nome do arquivo CSV.")
        raise
```

### Limpar os IDs
Remove "Gaia DR2" dos nomes dos objetos mantendo apenas seus IDs
```{python}
print("Iniciando a limpeza dos IDs...")
try:
    dr2_id_strings = main_table['GaiaDR2'].tolist()
    
    dr2_ids_cleaned_list = []
    ids_pulados = 0
    
    for s in dr2_id_strings:
        try:
            id_str = s.split(' ')[-1]
            numeric_id = np.int64(id_str) 
            dr2_ids_cleaned_list.append(numeric_id)
        except (AttributeError, IndexError, ValueError):
            ids_pulados += 1
            
    print(f"Encontrada e limpa a lista de \
        {len(dr2_ids_cleaned_list)} IDs (DR2) válidos.")
    if ids_pulados > 0:
        print(f"({ids_pulados} linhas foram puladas por não \
            terem um ID válido)")

except (KeyError) as e:
    print(f"Erro: A coluna 'GaiaDR2' não foi encontrada na 'main_table'.")
    raise
```

### Cria a tabela para upload e a query organizada

```{python}
upload_table = Table({'dr2_source_id_list': dr2_ids_cleaned_list})

# 1. Começa com a sua tabela (user_table)
# 2. Usa o nome correto da tabela (gaiadr3.dr2_neighbourhood) 
# para cruzar os IDs
query_dr3 = """
SELECT
    dr3.source_id, dr3.ra, dr3.dec, dr3.parallax, dr3.pmra, 
    dr3.pmdec, xmatch.angular_distance, 
    dr3.l, dr3.b, xmatch.magnitude_difference, dr3.ruwe,
    dr3.phot_g_mean_mag, dr3.bp_rp           
FROM
    tap_upload.my_table AS user_table
JOIN
    gaiadr3.dr2_neighbourhood AS xmatch
    ON user_table.dr2_source_id_list = xmatch.dr2_source_id
JOIN
    gaiadr3.gaia_source AS dr3
    ON xmatch.dr3_source_id = dr3.source_id
"""
```

### Executa a busca 
```{python}
print("Iniciando a busca no Gaia DR3 (com query otimizada)...")

try:
    job = Gaia.launch_job_async(
        query=query_dr3,
        upload_resource=upload_table,
        upload_table_name="my_table",
        verbose=True  # Adiciona mais informações de debug
    )
    
    results_dr3_members = job.get_results()

    print(f"\nBusca concluída!")
    print(f"Foram encontrados dados no DR3 para {len(results_dr3_members)} \
        das {len(dr2_ids_cleaned_list)} estrelas.")

    print("\n--- 5 primeiras linhas dos membros de Taurus (dados do DR3) ---")
    print(results_dr3_members.to_pandas().head())

    # Salva os resultados 
    results_dr3_members.write('taurus_membros_dr3.csv', 
        format='csv', overwrite=True)

except Exception as e:
    print(f"\nOcorreu um erro durante a busca no Gaia:")
    print(e)
```

# 2. Seleção da Amostra
### Carregando tabelas
```{python}
data = pd.read_csv('taurus_membros_dr3.csv')
df = pd.DataFrame(data)
#X = df[['ra', 'dec', 'parallax', 'pmra', 'pmdec']]
#print(X['ra'])
#print(df)
# 1. Calcula as contagens de cada source_id
counts = df['source_id'].value_counts()

# 2. Usa .map() para criar uma nova série do mesmo tamanho do df,
#    onde cada valor é a contagem do seu respectivo source_id.
#    Depois, compara com 2 para criar o filtro correto.
full_table = df[df['source_id'].map(counts) == 2]

full_table
```

```{python}
import numpy as np

# A maneira mais eficiente, correta e idiomática (Pythonic) de fazer isso:

df_filtered = df.sort_values(
    by='source_id',              # Critério de agrupamento (primeira ordenação)
    ascending=True
).sort_values(
    # 1º Critério: Mínimo do valor absoluto da diferença angular
    # Usamos o .abs() diretamente na coluna.
    by=['angular_distance', 'magnitude_difference'], 
    key=lambda x: np.abs(x),  # APLICA np.abs() (módulo) a AMBAS as colunas
    ascending=True,
    kind='stable' # Mantém a ordem da ordenação anterior ('source_id')
).drop_duplicates(
    subset=['source_id'], # Coluna que define o que é 'único'
    keep='first'          # Mantém a linha que ficou no topo após a ordenação
)

print(df_filtered.head())
```

### Exclui valores de RUWE <= 1.4
```{python}

# Aplicar o filtro RUWE, como no artigo
df_cleaned = df_filtered[df_filtered['ruwe'] <= 1.4].copy()
print(f"Amostra original: {len(df_filtered)} estrelas")
print(f"Amostra limpa (RUWE <= 1.4): {len(df_cleaned)} estrelas")
```

### Plota dados 
```{python}
plt.figure()
plt.plot(df_cleaned['l'],df_cleaned['b'], '.')
plt.gca().invert_xaxis()
plt.xlabel('l (°)', fontsize=12)
plt.ylabel('b (°)', fontsize=12)
plt.show()
```

# 3. Clustering
### K-means

```{python}
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score, silhouette_samples
import numpy as np
import matplotlib.pyplot as plt

# --- 1. PREPARAÇÃO DOS DADOS ---
# (Isto é o que você fez na sua seção DBSCAN)

features = ['ra', 'dec', 'parallax', 'pmra', 'pmdec']
X = df_cleaned[features]

# Normaliza os dados
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

print("Iniciando análise K-Means com dados NORMALIZADOS...")

# --- 2. ANÁLISE K-MEANS ---
# (Este é o seu código, mas usando X_scaled)

range_n_clusters = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
avg_silhouettes = []

for n_clusters in range_n_clusters:
    # Initialize the clusterer with n_clusters value and a random generator
    # seed of 10 for reproducibility.
    # Adicionado n_init=10 para garantir consistência
    clusterer = KMeans(n_clusters=n_clusters, random_state=10, n_init=10) 
    
    # --- CORREÇÃO AQUI ---
    # Use os dados normalizados (X_scaled)
    cluster_labels = clusterer.fit_predict(X_scaled) 

    # The silhouette_score gives the average value for all the samples.
    # This gives a perspective into the density and separation of the formed
    # clusters
    
    # --- CORREÇÃO AQUI ---
    # Use os dados normalizados (X_scaled)
    silhouette_avg = silhouette_score(X_scaled, cluster_labels) 
    print(
        "For n_clusters =",
        n_clusters,
        "The average silhouette_score is :",
        silhouette_avg,
    )
    avg_silhouettes.append(silhouette_avg)

# Encontra o melhor cluster
best_cluster_index = np.argmax(avg_silhouettes)
best_n_clusters = range_n_clusters[best_cluster_index]
best_silhouette_score = avg_silhouettes[best_cluster_index]

print(f"highest value = {best_silhouette_score}, n_clusters = {best_n_clusters}")

# Roda o K-Means final com o melhor n_clusters
clusterer = KMeans(n_clusters=best_n_clusters, random_state=10, n_init=10)
# --- CORREÇÃO AQUI ---
cluster_labels = clusterer.fit_predict(X_scaled) 

# Adiciona os rótulos ao DataFrame para os plots de CMD
df_cleaned['cluster_kmeans'] = cluster_labels 

# --- 3. PLOTAGEM ---
# (Seu código de plotagem está correto)

plt.figure(figsize=(10, 6)) # Define um tamanho de figura mais padrão
plt.plot(range_n_clusters, avg_silhouettes, '-', marker='o')
plt.xlabel('k (Número de Clusters)', fontsize=12)
plt.ylabel('Average Silhouette Score', fontsize=12)
plt.title('Método da Silhueta (com dados Normalizados)')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()


# --- Gráfico 2: Mapa de Clusters ---
fig, ax = plt.subplots(figsize=(10, 8)) # Cria uma figura e um eixo

# Plota os dados no eixo (ax)
ax.scatter(df_cleaned['l'], df_cleaned['b'], c=cluster_labels) 

# Inverte o eixo x (aplicado ao 'ax' correto)
ax.invert_xaxis() 

# Configura os rótulos e título
ax.set_xlabel('l (°)', fontsize=12)
ax.set_ylabel('b (°)', fontsize=12)
ax.set_title(f'Clusters K-Means (k={best_n_clusters})')
ax.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

### DBSCAN

```{python}
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import DBSCAN
import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import NearestNeighbors

# Assumindo que 'df_cleaned' é o seu DataFrame com o filtro RUWE já aplicado

# 1. Selecionar os dados para o clustering
features = ['ra', 'dec', 'parallax', 'pmra', 'pmdec']
X = df_cleaned[features]

# 2. Normalizar os dados (O PASSO MAIS IMPORTANTE)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 3. ESCOLHER OS PARÂMETROS PARA OS DADOS NORMALIZADOS
# O eps=0.5 não faz mais sentido. Precisamos encontrar um novo valor.

# --- Como escolher min_samples ---
# Uma boa regra é usar min_samples >= 2 * n_dimensões
# Para 5 dimensões, um bom começo é min_samples = 10 a 15.
min_samples = 5

# --- Como escolher eps (Método do "Joelho" ou K-distance) ---
# Vamos plotar a distância de cada ponto para o seu 15º vizinho mais próximo
# e procurar por um "joelho" (cotovelo) no gráfico.
print("Calculando o gráfico k-distance para encontrar o melhor 'eps'...")
neighbors = NearestNeighbors(n_neighbors=min_samples)
neighbors_fit = neighbors.fit(X_scaled)
distances, indices = neighbors_fit.kneighbors(X_scaled)

# Pega a distância para o k-ésimo vizinho (k = min_samples) e ordena
distances = np.sort(distances[:, min_samples-1], axis=0)

# Plota o gráfico
plt.figure(figsize=(10, 6))
plt.plot(distances)
plt.title('Gráfico K-distance para Escolha do Epsilon (eps)')
plt.xlabel('Pontos (ordenados por distância)')
plt.ylabel(f'Distância para o {min_samples}º Vizinho Mais Próximo')
plt.grid(True)
plt.show()

# OLHE O GRÁFICO! Onde a curva começa a subir abruptamente?
# Esse é o seu valor ideal para 'eps'. Digamos que seja 1.2, por exemplo.
# Você precisará ajustar este valor com base no seu gráfico.
eps_ideal = 1 # <-- AJUSTE ESTE VALOR COM BASE NO SEU GRÁFICO

# 4. Rodar o DBSCAN com os dados normalizados e parâmetros corretos
print(f"\nRodando DBSCAN com eps={eps_ideal} e min_samples={min_samples}")
db = DBSCAN(eps=eps_ideal, min_samples=min_samples).fit(X_scaled)
labels = db.labels_

# 5. Analisar os resultados
n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_noise_ = list(labels).count(-1)

print(f"\nNúmero estimado de clusters: {n_clusters_}")
print(f"Número estimado de pontos de ruído: {n_noise_}")

# Adicionar os labels dos clusters de volta ao DataFrame para análise
df_cleaned['cluster_dbscan'] = labels
print("\nDistribuição de estrelas por cluster:")
print(df_cleaned['cluster_dbscan'].value_counts())
```


```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Assuma que 'df_cleaned' é o seu DataFrame final com os dados e os rótulos do DBSCAN
# Ex: df_cleaned['cluster_dbscan'] contém os resultados do DBSCAN

# Pega os rótulos e encontra quantos clusters únicos existem (sem contar o ruído)
labels = df_cleaned['cluster_dbscan']
unique_labels = set(labels)
n_clusters = len(unique_labels) - (1 if -1 in labels else 0)

# Cria uma paleta de cores para os clusters
# Usamos cm.rainbow para gerar cores distintas
colors = cm.rainbow(np.linspace(0, 1, len(unique_labels)))

# Inicia a figura do gráfico
fig, ax = plt.subplots(figsize=(12, 10))

# Itera sobre cada cluster único e o plota com uma cor diferente
for k, col in zip(unique_labels, colors):
    # --- Estilo para os pontos de ruído (label = -1) ---
    if k == -1:
        # Ruído será plotado como pequenos 'x' pretos e semi-transparentes
        col = [0, 0, 0, 0.3]  # RGBA: Preto com 30% de opacidade
        marker = 'x'
        size = 20
        plot_label = f'Ruído ({list(labels).count(-1)} estrelas)'
    # --- Estilo para os clusters reais (label >= 0) ---
    else:
        # Clusters serão plotados como círculos coloridos
        marker = 'o'
        size = 50
        plot_label = f'{k+1}'

    # Cria uma máscara para selecionar apenas as estrelas do cluster atual
    class_member_mask = (labels == k)
    
    # Seleciona os dados do cluster atual
    xy = df_cleaned[class_member_mask]
    
    # Plota os pontos no gráfico
    ax.scatter(xy['l'], xy['b'], s=size, c=[col], marker=marker, label=plot_label, edgecolor='black', linewidths=0.5)

# --- Finalização e customização do gráfico ---
ax.set_title(f'DBSCAN Região de Taurus ({n_clusters} clusters)', fontsize=14)
ax.set_xlabel('l(°)', fontsize=12)
ax.set_ylabel('b(°)', fontsize=12)

# Inverte o eixo X, como é comum em mapas celestes
ax.invert_xaxis() 

#ax.legend(loc='upper right')
ax.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

### HDBSCAN

```{python}
features = ['ra', 'dec', 'parallax', 'pmra', 'pmdec']
X = df_cleaned[features]

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 2. Implementar o HDBSCAN do Scikit-learn
print("Rodando HDBSCAN (do Scikit-learn)...")
clusterer = HDBSCAN(
    min_cluster_size=15,  # <-- O seu parâmetro principal
    min_samples=10        # <-- Parâmetro de ajuste fino (opcional)
)

clusterer.fit(X_scaled)

# 3. Analisar os resultados (Igual)
labels = clusterer.labels_

n_clusters_ = len(set(labels)) - (1 if -1 in labels else 0)
n_noise_ = list(labels).count(-1)

print(f"\nNúmero estimado de clusters: {n_clusters_}")
print(f"Número estimado de pontos de ruído: {n_noise_}")

# Adicionar os labels dos clusters de volta ao DataFrame
df_cleaned['cluster_hdbscan'] = labels
print("\nDistribuição de estrelas por cluster:")
print(df_cleaned['cluster_hdbscan'].value_counts())
```


```{python}
# Assuma que 'df_cleaned' é o seu DataFrame com a coluna 'cluster_hdbscan'

# Pega os rótulos e encontra quantos clusters únicos existem (sem contar o ruído)
labels = df_cleaned['cluster_hdbscan']
unique_labels = set(labels)
n_clusters = len(unique_labels) - (1 if -1 in labels else 0)

# Cria uma paleta de cores para os clusters
colors = cm.rainbow(np.linspace(0, 1, len(unique_labels)))

# Inicia a figura do gráfico
fig, ax = plt.subplots(figsize=(12, 10))

# Itera sobre cada cluster único e o plota com uma cor diferente
for k, col in zip(unique_labels, colors):
    # --- Estilo para os pontos de ruído (label = -1) ---
    if k == -1:
        col = [0, 0, 0, 0.3]  # RGBA: Preto com 30% de opacidade
        marker = 'x'
        size = 20
        plot_label = f'Ruído ({list(labels).count(-1)} estrelas)'
    # --- Estilo para os clusters reais (label >= 0) ---
    else:
        marker = 'o'
        size = 50
        plot_label = f'Cluster {k}'

    # Cria uma máscara para selecionar apenas as estrelas do cluster atual
    class_member_mask = (labels == k)
    
    # Seleciona os dados do cluster atual
    xy = df_cleaned[class_member_mask]
    
    # Plota os pontos no gráfico
    ax.scatter(xy['l'], xy['b'], s=size, c=[col], marker=marker, label=plot_label, edgecolor='black', linewidths=0.5)

# --- Finalização e customização do gráfico ---
ax.set_title(f'HDBSCAN Região de Taurus ({n_clusters} clusters)', fontsize=14)
ax.set_xlabel('l(°)', fontsize=12)
ax.set_ylabel('b(°)', fontsize=12)
# Inverte o eixo X, como é comum em mapas celestes
ax.invert_xaxis() 

#ax.legend(loc='upper right')
ax.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

### CMDs

```{python}
import matplotlib.pyplot as plt
import pandas as pd
import math

# --- Configuração dos Dados (Igual ao seu código original) ---
labels = df_cleaned['cluster_hdbscan']
noise_data = df_cleaned[labels == -1]
cluster_ids = sorted([c for c in labels.unique() if c >= 0])
n_clusters = len(cluster_ids)

print(f"Gerando mosaico para {n_clusters} clusters...")

# --- Configuração do Grid (Mosaico) ---
# Define quantas colunas você quer (ex: 3 ou 4)
n_cols = 3 
# Calcula quantas linhas são necessárias (arredonda para cima)
n_rows = math.ceil(n_clusters / n_cols)

# Cria a figura gigante e os eixos (axs)
# figsize ajustado: largura fixa, altura cresce com o número de linhas
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows), constrained_layout=True)

# Transforma a matriz de eixos em uma lista linear para facilitar o loop
# (Trata o caso de haver apenas 1 cluster para evitar erro)
if n_clusters > 1:
    axs = axs.flatten()
else:
    axs = [axs]

# --- Loop de Plotagem ---
for i, ax in enumerate(axs):
    # Verifica se ainda temos clusters para plotar
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        # 1. Plota o "campo" de ruído
        # DICA: rasterized=True ajuda a deixar o PDF/SVG mais leve se tiver muitos pontos
        ax.scatter(
            noise_data['bp_rp'], 
            noise_data['phot_g_mean_mag'], 
            c='gray', 
            s=1, 
            alpha=0.05,  # Reduzi a opacidade pois o gráfico fica menor
            label='Ruído' if i == 0 else "", # Legenda só no primeiro para não poluir
            rasterized=True 
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['bp_rp'], 
            cluster_data['phot_g_mean_mag'], 
            c='orange', 
            s=10, 
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # --- Customização Específica do Eixo (ax) ---
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('Cor ($G_{BP} - G_{RP}$)', fontsize=10)
        ax.set_ylabel('Magnitude G', fontsize=10)
        
        ax.invert_yaxis() # Inverte Y (Fundamental para CMD)
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)

    else:
        # Se acabaram os clusters mas sobraram "quadradinhos" no grid, desligue-os
        ax.axis('off')

# Título geral da figura (opcional)
fig.suptitle(f'Análise de Clusters HDBSCAN - Total: {n_clusters}', fontsize=20, y=1.06)

plt.show()
```


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- Configuração dos Dados ---
# Assumindo que 'df_cleaned' é o seu DataFrame
labels = df_cleaned['cluster_dbscan'] # <-- MUDANÇA AQUI
noise_data = df_cleaned[labels == -1]
cluster_ids = sorted([c for c in labels.unique() if c >= 0])
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de CMDs para {n_clusters} clusters do DBSCAN...")

# --- Configuração do Grid (Mosaico) ---
n_cols = 3 # 3 colunas
n_rows = math.ceil(n_clusters / n_cols) # Calcula as linhas
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows), constrained_layout=True)

if n_clusters > 1:
    axs = axs.flatten()
else:
    axs = [axs]

# --- Loop de Plotagem ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        # 1. Plota o "campo" de ruído
        ax.scatter(
            noise_data['bp_rp'],
            noise_data['phot_g_mean_mag'],
            c='gray',
            s=1,
            alpha=0.05,
            label='Ruído' if i == 0 else "",
            rasterized=True
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['bp_rp'],
            cluster_data['phot_g_mean_mag'],
            c='orange',
            s=10,
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # Customização do eixo
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('Cor ($G_{BP} - G_{RP}$)', fontsize=10)
        ax.set_ylabel('Magnitude G', fontsize=10)
        ax.invert_yaxis()
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)
    
    else:
        # Desliga eixos extras
        ax.axis('off')

fig.suptitle(f'Análise de CMDs - DBSCAN (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math
from sklearn.cluster import KMeans

# --- 1. GARANTIR QUE O K-MEANS CORRETO FOI EXECUTADO ---
# (Este bloco já está no seu notebook)

# features = ['ra', 'dec', 'parallax', 'pmra', 'pmdec']
# X = df_cleaned[features]
# scaler = StandardScaler()
# X_scaled = scaler.fit_transform(X)
# n_clusters_kmeans = 8 
# kmeans = KMeans(n_clusters=n_clusters_kmeans, random_state=10, n_init=10)
# kmeans_labels = kmeans.fit_predict(X_scaled) 
# df_cleaned['cluster_kmeans'] = kmeans_labels

# --- 2. GERAR O MOSAICO DE PLOTS (Seu código da pág. 32) ---

labels = df_cleaned['cluster_kmeans']
cluster_ids = sorted(labels.unique()) # K-Means não tem -1
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de CMDs para {n_clusters} clusters do K-Means...")

# --- Configuração do Grid (Mosaico) ---
n_cols = 5
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 3 * n_rows), constrained_layout=True)
axs = axs.flatten()

# --- Loop de Plotagem ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        
        # Dados deste cluster (para plotar em laranja)
        cluster_data = df_cleaned[labels == cluster_id]
        
        # Dados de "fundo" (TODOS os outros clusters)
        background_data = df_cleaned[labels != cluster_id] 
        
        # 1. Plota o "fundo" (outros clusters)
        ax.scatter(
            background_data['bp_rp'],
            background_data['phot_g_mean_mag'],
            c='gray',
            s=1,
            alpha=0.05,
            label='Outros Clusters' if i == 0 else "",
            rasterized=True
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['bp_rp'], 
            cluster_data['phot_g_mean_mag'], 
            c='orange', 
            s=10, 
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # Customização do eixo
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('Cor ($G_{BP} - G_{RP}$)', fontsize=10)
        ax.set_ylabel('Magnitude G', fontsize=10)
        ax.invert_yaxis()
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)
    
    else:
        # Desliga eixos extras
        ax.axis('off')

fig.suptitle(f'Análise de CMDs - K-Means (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```

### pmra x pmdec
### 1. K-means
```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
# Assumindo que 'df_cleaned' é o seu DataFrame
labels = df_cleaned['cluster_kmeans']
cluster_ids = sorted(labels.unique())
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de Movimento Próprio para {n_clusters} clusters do K-Means...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 5
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 3 * n_rows), constrained_layout=True)
axs = axs.flatten()

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        
        # Dados deste cluster (para plotar em laranja)
        cluster_data = df_cleaned[labels == cluster_id]
        
        # Dados de "fundo" (TODOS os outros clusters)
        background_data = df_cleaned[labels != cluster_id] 
        
        # 1. Plota o "fundo" (outros clusters)
        ax.scatter(
            background_data['pmra'], 
            background_data['pmdec'],
            c='gray',
            s=1,
            alpha=0.05,
            label='Outros Clusters' if i == 0 else "",
            rasterized=True
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['pmra'], 
            cluster_data['pmdec'], 
            c='orange', 
            s=10, 
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # Customização do eixo
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('$\mu_\\alpha$ (mas/yr)', fontsize=10) # Label de PMRA
        ax.set_ylabel('$\mu_\\delta$ (mas/yr)', fontsize=10) # Label de PMDEC
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)
    
    else:
        # Desliga eixos extras
        ax.axis('off')

fig.suptitle(f'Análise de Movimento Próprio - K-Means (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```

### 2. DBSCAN

```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
# Assumindo que 'df_cleaned' é o seu DataFrame
labels = df_cleaned['cluster_dbscan'] # <-- MUDANÇA AQUI
noise_data = df_cleaned[labels == -1]
cluster_ids = sorted([c for c in labels.unique() if c >= 0])
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de Movimento Próprio para {n_clusters} clusters do DBSCAN...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 3
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows), constrained_layout=True)

if n_clusters > 1:
    axs = axs.flatten()
else:
    axs = [axs]

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        # 1. Plota o "campo" de ruído
        ax.scatter(
            noise_data['pmra'], 
            noise_data['pmdec'],
            c='gray',
            s=1,
            alpha=0.05,
            label='Ruído' if i == 0 else "",
            rasterized=True
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['pmra'], 
            cluster_data['pmdec'], 
            c='orange', 
            s=10, 
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # Customização do eixo
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('$\mu_\\alpha$ (mas/yr)', fontsize=10)
        ax.set_ylabel('$\mu_\\delta$ (mas/yr)', fontsize=10)
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)
    
    else:
        # Desliga eixos extras
        ax.axis('off')

fig.suptitle(f'Análise de Movimento Próprio - DBSCAN (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```

### HDBSCAN


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
# Assumindo que 'df_cleaned' é o seu DataFrame
labels = df_cleaned['cluster_hdbscan'] # <-- MUDANÇA AQUI
noise_data = df_cleaned[labels == -1]
cluster_ids = sorted([c for c in labels.unique() if c >= 0])
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de Movimento Próprio para {n_clusters} clusters do HDBSCAN...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 3
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows), constrained_layout=True)

if n_clusters > 1:
    axs = axs.flatten()
else:
    axs = [axs]

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        # 1. Plota o "campo" de ruído
        ax.scatter(
            noise_data['pmra'], 
            noise_data['pmdec'],
            c='gray',
            s=1,
            alpha=0.05,
            label='Ruído' if i == 0 else "",
            rasterized=True
        )
        
        # 2. Plota os membros do cluster
        ax.scatter(
            cluster_data['pmra'], 
            cluster_data['pmdec'], 
            c='orange', 
            s=10, 
            label=f'ID {cluster_id} (N={len(cluster_data)})',
            edgecolor='black',
            linewidth=0.3
        )
        
        # Customização do eixo
        ax.set_title(f'Cluster {cluster_id}', fontsize=12, fontweight='bold')
        ax.set_xlabel('$\mu_\\alpha$ (mas/ano)', fontsize=10)
        ax.set_ylabel('$\mu_\\delta$ (mas/ano)', fontsize=10)
        ax.grid(True, linestyle='--', alpha=0.5)
        ax.legend(loc='best', fontsize='small', frameon=True)
    
    else:
        # Desliga eixos extras
        ax.axis('off')

fig.suptitle(f'Análise de Movimento Próprio - HDBSCAN (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```

### Paralaxes
### 1. K-means


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
# Assumindo que 'df_cleaned' é o seu DataFrame
labels = df_cleaned['cluster_kmeans']
cluster_ids = sorted(labels.unique())
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de histogramas de paralaxe para {n_clusters} clusters do K-Means...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 4
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 3 * n_rows), constrained_layout=True)
axs = axs.flatten()

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        # Plota o histograma
        ax.hist(cluster_data['parallax'], bins=10, edgecolor='black', alpha=0.7)
        
        # Customização
        ax.set_title(f'Cluster {cluster_id} (N={len(cluster_data)})', fontsize=12, fontweight='bold')
        ax.set_xlabel('Paralaxe (mas)', fontsize=10)
        ax.set_ylabel('Contagem', fontsize=10)
        ax.grid(True, linestyle='--', alpha=0.5)
    else:
        ax.axis('off')

fig.suptitle(f'Histogramas de Paralaxe - K-Means (Total: {n_clusters} clusters)', fontsize=20, y=1.06)
plt.show()
```

### 2. DBSCAN


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
labels = df_cleaned['cluster_dbscan']
cluster_ids = sorted(labels.unique()) # Inclui o -1 (ruído)
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de histogramas de paralaxe para DBSCAN...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 4
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 4 * n_rows), constrained_layout=True)
axs = axs.flatten()

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        plot_title = f'Cluster {cluster_id} (N={len(cluster_data)})'
        color = 'blue'
        
        if cluster_id == -1:
            plot_title = f'Ruído (N={len(cluster_data)})'
            color = 'gray'
        
        # Plota o histograma
        ax.hist(cluster_data['parallax'], bins=15, edgecolor='black', alpha=0.7, color=color)
        
        # Customização
        ax.set_title(plot_title, fontsize=12, fontweight='bold')
        ax.set_xlabel('Paralaxe (mas)', fontsize=10)
        ax.set_ylabel('Contagem', fontsize=10)
        ax.grid(True, linestyle='--', alpha=0.5)
    else:
        ax.axis('off')

fig.suptitle(f'Histogramas de Paralaxe - DBSCAN', fontsize=20, y=1.06)
plt.show()
```

### 3. HDBSCAN


```{python}
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import matplotlib.cm as cm
import math

# --- 1. CONFIGURAÇÃO DOS DADOS ---
labels = df_cleaned['cluster_hdbscan']
cluster_ids = sorted(labels.unique()) # Inclui o -1 (ruído)
n_clusters = len(cluster_ids)

print(f"Gerando mosaico de histogramas de paralaxe para HDBSCAN...")

# --- 2. CONFIGURAÇÃO DO GRID ---
n_cols = 3
n_rows = math.ceil(n_clusters / n_cols)
fig, axs = plt.subplots(n_rows, n_cols, figsize=(15, 4 * n_rows), constrained_layout=True)
axs = axs.flatten()

# --- 3. LOOP DE PLOTAGEM ---
for i, ax in enumerate(axs):
    if i < n_clusters:
        cluster_id = cluster_ids[i]
        cluster_data = df_cleaned[labels == cluster_id]
        
        plot_title = f'Cluster {cluster_id} (N={len(cluster_data)})'
        color = 'green'
        
        if cluster_id == -1:
            plot_title = f'Ruído (N={len(cluster_data)})'
            color = 'gray'
        
        # Plota o histograma
        ax.hist(cluster_data['parallax'], bins=15, edgecolor='black', alpha=0.7, color=color)
        
        # Customização
        ax.set_title(plot_title, fontsize=12, fontweight='bold')
        ax.set_xlabel('Paralaxe (mas)', fontsize=10)
        ax.set_ylabel('Contagem', fontsize=10)
        ax.grid(True, linestyle='--', alpha=0.5)
    else:
        ax.axis('off')

fig.suptitle(f'Histogramas de Paralaxe - HDBSCAN', fontsize=20, y=1.06)
plt.show()
```